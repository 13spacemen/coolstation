/* ._.-'~'-._.-'~'-._.-'~'-._.-'~'-._.-'~'-._. */
/*-=-=-=-=-=-=-=STAT LOGGER BY WIRE-=-=-=-=-=-=*/
/* '~'-._.-'~'-._.-'~'-._.-'~'-._.-'~'-._.-'~' */

/// Whether or not debug logging is enabled
#define STATS_LOG_DEBUG TRUE

/// Holder for [/datum/stats]
var/global/datum/stats/stats

/**
 * # Stats
 *
 * Holder datum for statistic event logging
 *
 * Handles building stat events with metadata, and formatting them in such a
 * way that the backend stat parsing service can ingest
 *
 * Usage:
 * ```
 * stats.record("bee_farts", list("bee_name" = "Tootington the Third"))
 * ```
 */
/datum/stats
	/// The base path for all stat log files
	var/stats_path = "data/stats"
	/// The file handler for stat logging this round
	var/log_file
	/// A queue of stat records we couldn't save immediately (probably because we didn't have a round ID yet)
	var/list/queue = list()
	/// A list of foreign relationship definitions
	var/list/foreign_relations = list()

	New()
		..()
		// Build out all the foreign relationship definitions ahead of time
		for (var/type in concrete_typesof(/datum/stats_foreign))
			src.foreign_relations[type] = new type

	/**
	 * Debug logging. Only does anything if the [STATS_LOG_DEBUG] define is truthy
	 *
	 * Arguments:
	 * * message - A string describing the event
	 * * data - Data of any type that will be appended to the log as a json encoded string
	 */
	proc/log_debug(message = "", data)
		#if STATS_LOG_DEBUG
		logTheThing("debug", null, null, "<b>Stats Debug</b>: [message]. Data: [json_encode(data)]")
		#endif

	/**
	 * Create a file pointer for this round that will be used for storing stats
	 */
	proc/setup_file()
		if (!round_id) return
		src.log_file = file("[src.stats_path]/[round_id].log")

	/**
	 * Send a stat item to our previously created stat file pointer
	 *
	 * Arguments:
	 * * item - The stat event item
	 */
	proc/send_to_file(list/item)
		if (!src.log_file)
			throw EXCEPTION("Stat log file does not exist")
		src.log_file << json_encode(item)

	/**
	 * Record all stats that were cached in the queue
	 * Additionally appends round_id to every item that is missing it
	 */
	proc/flush_queue()
		if (!round_id) return
		src.log_debug("Flushing queue of length: [length(src.queue)]")
		for (var/list/item in src.queue)
			if (!item["round_id"]) item["round_id"] = round_id
			src.send_to_file(item)
		src.queue = list()

	/**
	 * Record a stat event
	 * If a global round ID is not yet present, stat events will be queued
	 *
	 * Arguments:
	 * * type - Discriminator for this event (e.g. bee_farts)
	 * * data - Data representing the event
	 * * foreign_path - A path of type [/datum/stats_foreign]. Informs the stat parser on the API backend service that it should retrieve additional data via a foreign table relationship.
	 */
	proc/record(type = "", list/data, foreign_path)
		var/list/item = list(
			"type" = type,
			"round_id" = round_id,
			"timestamp" = time2text(world.realtime, "YYYY-MM-DD hh:mm:ss"),
			"data" = data
		)

		if (foreign_path)
			var/datum/stats_foreign/foreign = src.foreign_relations[foreign_path]
			if (!item["data"][foreign.source_key])
				src.log_debug("Bad foreign usage for [foreign_path], source_key '[foreign.source_key]' doesn't exist", item)
				throw EXCEPTION("Attempt to relate foreign config of type [foreign_path] from non-existent data property [foreign.source_key]")
			item["foreign"] = foreign.to_list()

		if (!src.log_file)
			src.log_debug("Queueing item", item)
			src.queue += list(item)
			return

		src.log_debug("Recording item", item)
		src.send_to_file(item)

	/**
	 * Lots of stuff is reliant on the round ID being provided by the backend
	 * API, so here is a handy dandy event that's called when it is
	 */
	proc/on_round_id_available()
		src.setup_file()
		src.flush_queue()


/**
 * # Stat foreign relations
 *
 * Provides definitions for common types of stat foreign relationships
 *
 * Foreign relationships are used when the backend API service holds additional
 * information that we want attached to our stat event that isn't present ingame.
 */
/datum/stats_foreign
	/// The key name in our 'data' object that we want to lookup with
	var/source_key
	/// The key name in our 'data' object that we want the retrieved foreign value to be put in
	var/source_column
	/// The foreign table name containing the thing we want
	var/foreign_table
	/// The foreign table column that we search against with the value of "source_key"
	var/foreign_column
	/// The foreign table column that we actually want
	var/return_column

	/**
	 * Transform a foreign relationship definition to a list
	 */
	proc/to_list()
		return list(
			"source_key" = src.source_key,
			"source_column" = src.source_column,
			"foreign_table" = src.foreign_table,
			"foreign_column" = src.foreign_column,
			"return_column" = src.return_column,
		)

	/**
	 * A relationship to attach the unique player ID generated by the backend
	 * API by providing a ckey. Useful if the query to retrieve the player ID
	 * has not yet happened
	 */
	player
		source_key = "player_ckey"
		source_column = "player_id"
		foreign_table = "players"
		foreign_column = "ckey"
		return_column = "id"

ABSTRACT_TYPE(/datum/stats_foreign)
